面向对象有哪些特性，你需要回答下三大特性，并且在回答的时候解释一下，最好可以举一些例子
当然，时间多的，就好好看下吧

封装
encapsulation
把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作

好处：
1.隐藏实现细节
2.可以对数据进行验证，保证安全合理



实现步骤：
1.将属性私有化（不能直接修改属性）
2.提供一个公共的set方法，用于对属性判断并赋值
public void setXxx(类型，参数名){  //Xxx表示某个属性
//加入数据验证的业务逻辑
属性=参数名；
}
3.提供一个公共的get方法，用户获取属性的值
public XX getXxx(){   //权限判断
 return xx;
}

 问题：若直接使用构造器指定属性，验证就失效了
 解决：将set方法写在构造器中，这样就可以验证了


继承

解决代码复用问题
当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，
所有子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。

基本语法：
class 子类 extends 父类{
}
1.子类就会自动拥有父类定义的属性和方法
2.父类又叫超类，基类
3.子类又叫派生类

好处
1.代码复用性提高
2.代码扩展性和维护性提高

//Ctrl+H  可以查看类的继承关系


细节问题：
1.子类继承了所有的属性和方法，但是私有属性不能在子类直接访问，要通过公共的方法去访问
2.子类必须调用父类的构造器，完成父类的初始化
3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下，总会去调用父类的无参构造器，
若父类没有提供无参构造器，则必须在子类的构造器中用super， 去指定使用父类的哪个构造器，
完成对父类的初始化工作，否则，编译不会通过
4.如果希望指定去调用父类的某个构造器，则显式的调用一下
5.super在使用时，必须放在构造器第一行
6.super() 和this() 都只能放在构造器第一行，所以这两个方法不能 共存在一个构造器中
7.java所有类都是Object类的子类，Object是所有类的基类
8.父类构造器的调用不限于直接父类，将一直往上追溯直到Object类（顶级父类）
9.子类最多只能继承一个父类（指直接继承），即java中是单继承机制
10.不能滥用继承，子类和父类之间必须满足is-a的逻辑关系

继承的本质：（重要）
当子类继承父类，创建子类对象时，内存发生了什么：
当子类对象创建好后，建立查找的关系

super关键字：
代表父类的引用，用于访问父类的属性、方法、构造器

基本语法：
1.访问父类的属性，但不能访问父类的private属性
super.属性名
2.访问父类的方法，但不能访问父类的private方法
super.方法名（参数列表）
3.访问父类的构造器，只能放在子类构造器的第一句
super（参数列表）

和 this 一样，了解下就行，面试时，可能会问 this 和 super 的区别，你们需要解释下。
super的好处：
1.调用父类的构造器的好处
分工明确，父类属性由父类初始化，子类的属性由子类初始化
2.当子类中有和父类中的成员重名时，为了访问父类的成员，必须通过super。
如果没有重名，使用super、this、直接访问是一样的效果
3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；
如果多个基类中都有同名的成员，使用super访问遵循就近原则

方法重写/覆盖（override）
定义：
就是子类有个方法，和父类的某个方法的名称、返回类型、参数一样，
就说子类的这个方法覆盖了父类的方法，包括直接父类和间接父类

注意事项：
1.子类方法的参数、方法名称，要和父类方法的参数、方法名称完全一样
2.子类方法的返回类型和父类方法返回类型一样，或者，是父类返回类型的子类
如：父类的返回类型是Object，子类方法返回类型是String
3.子类方法不能缩小父类方法的访问权限

基础知识，另外就是要了解重写和重载的区别，一般面试就问这个。
这个其实和多态有关，后面学习虚拟机，也会学到这个。

           发生范围  方法名       形参列表                                     返回类型  修饰符
重载       本类    必须一样    类型，个数或顺序至少有一个不同   无要求      无要求
重写      父子类  必须一样        相同                                        注意事项2 注意事项3


多态
这个 多态，有点难度，可能学了有点容易忘记，自己可以多动手试试，
后面学习虚拟机的时候，应该就会更加理解多态的本质了
定义：
方法或对象具有多种形态，建立在封装和继承基础之上的

多太的具体体现：
1.方法的多态
重写和重载就体现多态
2.对象的多态（核心）
  1.一个对象的编译类型和运行类型可以不一致
  2.编译类型在定义对象时，就确定了，不能改变
  3.运行类型是可以变化的
  4.编译类型看定义时 = 号的左边，运行类型看  = 号的右边

多态注意事项和细节
1、多态的前提：两个对象（类）存在继承关系

2、多态的向上转型
  1.本质：父类的引用指向了子类的对象
  2.语法：父类类型  引用名 = new 子类类型();
  3.特点：编译类型看左边，运行类型看右边
    可以调用父类中的所有成员（需遵循访问权限），
    不能调用子类中特有成员
    最终运行效果看子类的具体实现

3、多态的向下转型
  1.语法：子类类型   引用名 = （子类类型）父类引用
  2.只能强转父类的引用，不能强转父类的对象
  3.要求父类的引用必须指向的是当前目标类型的对象
  4.当向下转型后，可以调用子类类型中所有的成员

4、属性没有重写之说，属性的值看编译类型

5、instanceOf 比较操作符，用于判断对象的  运行类型  是否为XX类型或XX类型的子类型

java的动态绑定机制（非常重要）
1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

多态的应用
 1.多态数组
  数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
 2.多态参数
  方法定义的形参类型为父类类型，实参类型允许为子类类型

